import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type {
  Guest,
  Couple,
  ExclusionConstraint,
  PlanConfiguration,
  SeatingPlanResult,
  TablePosition,
} from '@/types';
import { generateSeatingPlan, generateId } from '@/lib/algorithm';

// ============================================
// STORE INTERFACE
// ============================================

interface AppStore {
  // Data
  guests: Guest[];
  couples: Couple[];
  exclusions: ExclusionConstraint[];
  configuration: PlanConfiguration;
  
  // Generated result
  result: SeatingPlanResult | null;
  planNeedsRegeneration: boolean;
  
  // UI State
  viewMode: 'cards' | 'visual';
  isGenerating: boolean;
  tablePositions: TablePosition[];
  
  // Guest Actions
  addGuest: (guest: Omit<Guest, 'id'>) => { success: true; id: string } | { success: false; error: string };
  updateGuest: (id: string, updates: Partial<Guest>) => void;
  removeGuest: (id: string) => void;
  
  // Couple Actions
  addCouple: (guestAId: string, guestBId: string) => string;
  removeCouple: (id: string) => void;
  
  // Exclusion Actions
  addExclusion: (guestAId: string, guestBId: string) => string;
  removeExclusion: (id: string) => void;
  updateGuestExclusions: (guestId: string, excludedGuestIds: string[]) => void;
  
  // Configuration Actions
  updateConfiguration: (updates: Partial<PlanConfiguration>) => void;
  
  // Auto-complete Actions
  autoCompleteGuests: () => void;
  removeExcessAutoGeneratedGuests: (count: number) => void;

  // Generation Actions
  generate: () => void;
  
  // UI Actions
  setViewMode: (mode: 'cards' | 'visual') => void;
  updateTablePosition: (tableId: string, x: number, y: number) => void;
  
  // Drag & Drop Actions
  moveGuestToTable: (guestId: string, targetTableId: string) => void;
  
  // Table Actions
  renameTable: (tableId: string, newName: string) => void;
  
  // Reset
  reset: () => void;
}

// ============================================
// INITIAL STATE
// ============================================

const initialConfiguration: PlanConfiguration = {
  totalGuests: 50,
  numberOfTables: 6,
  seatsPerTable: 8,
  honorTableSeats: 10,
  sortingCriteria: {
    byFamily: false,
    byAge: false,
    byRole: true,
    random: false,
  },
  tableShape: 'round',
};

const initialState = {
  guests: [] as Guest[],
  couples: [] as Couple[],
  exclusions: [] as ExclusionConstraint[],
  configuration: initialConfiguration,
  result: null as SeatingPlanResult | null,
  planNeedsRegeneration: false,
  viewMode: 'cards' as const,
  isGenerating: false,
  tablePositions: [] as TablePosition[],
};

// ============================================
// STORE
// ============================================

export const useAppStore = create<AppStore>()(
  persist(
    (set, get) => ({
      ...initialState,

      // Guest Actions
      addGuest: (guestData) => {
        const { guests, configuration } = get();
        const maxGuests = configuration.totalGuests;
        
        // Check if we're at max capacity
        if (guests.length >= maxGuests) {
          // Try to find an auto-generated guest to remove (pattern: "Invité X" or "Guest X")
          const autoGeneratedGuest = guests.find(
            (g) => /^(Invité|Guest)\s+\d+$/.test(g.firstName) && !g.coupleId
          );
          
          if (autoGeneratedGuest) {
            // Remove the auto-generated guest first
            set((state) => ({
              guests: state.guests.filter((g) => g.id !== autoGeneratedGuest.id),
              exclusions: state.exclusions.filter(
                (e) => e.guestAId !== autoGeneratedGuest.id && e.guestBId !== autoGeneratedGuest.id
              ),
            }));
          } else {
            // No auto-generated guest to remove, return error
            return { 
              success: false as const, 
              error: 'MAX_GUESTS_REACHED' 
            };
          }
        }
        
        const id = generateId();
        const guest: Guest = {
          ...guestData,
          id,
        };
        set((state) => ({
          guests: [...state.guests, guest],
          planNeedsRegeneration: state.result !== null,
        }));
        return { success: true as const, id };
      },

      updateGuest: (id, updates) => {
        set((state) => ({
          guests: state.guests.map((g) =>
            g.id === id ? { ...g, ...updates } : g
          ),
          planNeedsRegeneration: state.result !== null,
        }));
      },

      removeGuest: (id) => {
        set((state) => ({
          guests: state.guests.filter((g) => g.id !== id),
          couples: state.couples.filter(
            (c) => c.guestAId !== id && c.guestBId !== id
          ),
          exclusions: state.exclusions.filter(
            (e) => e.guestAId !== id && e.guestBId !== id
          ),
          planNeedsRegeneration: state.result !== null,
        }));
      },

      // Couple Actions
      addCouple: (guestAId, guestBId) => {
        const id = generateId();
        const couple: Couple = { id, guestAId, guestBId };
        
        // Mettre à jour les références dans les invités
        set((state) => ({
          couples: [...state.couples, couple],
          guests: state.guests.map((g) => {
            if (g.id === guestAId || g.id === guestBId) {
              return { ...g, coupleId: id };
            }
            return g;
          }),
          planNeedsRegeneration: state.result !== null,
        }));
        
        return id;
      },

      removeCouple: (id) => {
        const couple = get().couples.find((c) => c.id === id);
        set((state) => ({
          couples: state.couples.filter((c) => c.id !== id),
          guests: state.guests.map((g) => {
            if (couple && (g.id === couple.guestAId || g.id === couple.guestBId)) {
              const { coupleId, ...rest } = g;
              return rest as Guest;
            }
            return g;
          }),
          planNeedsRegeneration: state.result !== null,
        }));
      },

      // Exclusion Actions
      addExclusion: (guestAId, guestBId) => {
        // Vérifier si l'exclusion existe déjà
        const exists = get().exclusions.some(
          (e) =>
            (e.guestAId === guestAId && e.guestBId === guestBId) ||
            (e.guestAId === guestBId && e.guestBId === guestAId)
        );
        
        if (exists) return '';
        
        const id = generateId();
        const exclusion: ExclusionConstraint = { id, guestAId, guestBId };
        set((state) => ({
          exclusions: [...state.exclusions, exclusion],
          planNeedsRegeneration: state.result !== null,
        }));
        return id;
      },

      removeExclusion: (id) => {
        set((state) => ({
          exclusions: state.exclusions.filter((e) => e.id !== id),
          planNeedsRegeneration: state.result !== null,
        }));
      },

      updateGuestExclusions: (guestId, excludedGuestIds) => {
        set((state) => {
          // Supprimer toutes les exclusions existantes pour cet invité
          const otherExclusions = state.exclusions.filter(
            (e) => e.guestAId !== guestId && e.guestBId !== guestId
          );
          
          // Créer les nouvelles exclusions
          const newExclusions = excludedGuestIds.map((excludedId) => ({
            id: generateId(),
            guestAId: guestId,
            guestBId: excludedId,
          }));
          
          return {
            exclusions: [...otherExclusions, ...newExclusions],
            planNeedsRegeneration: state.result !== null,
          };
        });
      },

      // Configuration Actions
      updateConfiguration: (updates) => {
        set((state) => {
          // tableShape est uniquement visuel, ne nécessite pas de régénération
          const needsRegeneration = state.result !== null && 
            Object.keys(updates).some(key => key !== 'tableShape');
          
          return {
            configuration: { ...state.configuration, ...updates },
            planNeedsRegeneration: needsRegeneration || state.planNeedsRegeneration,
          };
        });
      },

      // Auto-complete Actions
      autoCompleteGuests: () => {
        const { guests, configuration } = get();
        const missingCount = configuration.totalGuests - guests.length;
        
        if (missingCount <= 0) return;
        
        const newGuests: Guest[] = [];
        for (let i = 0; i < missingCount; i++) {
          const guestNumber = guests.length + i + 1;
          newGuests.push({
            id: generateId(),
            firstName: `Invité ${guestNumber}`,
            role: 'regular',
          });
        }
        
        set((state) => ({
          guests: [...state.guests, ...newGuests],
          planNeedsRegeneration: state.result !== null,
        }));
      },

      // Supprimer les invités auto-générés excédentaires
      removeExcessAutoGeneratedGuests: (count) => {
        const { guests, couples, exclusions } = get();
        
        // Identifier les invités auto-générés (ceux qui commencent par "Invité")
        const autoGenerated = guests.filter(g => g.firstName.startsWith('Invité'));
        const realGuests = guests.filter(g => !g.firstName.startsWith('Invité'));
        
        // Supprimer les derniers invités auto-générés
        const toRemove = autoGenerated.slice(-count);
        const toRemoveIds = new Set(toRemove.map(g => g.id));
        
        // Supprimer aussi les couples et exclusions liés
        const newCouples = couples.filter(c => !toRemoveIds.has(c.guestAId) && !toRemoveIds.has(c.guestBId));
        const newExclusions = exclusions.filter(e => !toRemoveIds.has(e.guestAId) && !toRemoveIds.has(e.guestBId));
        
        const remainingAutoGenerated = autoGenerated.slice(0, -count);
        
        set((state) => ({
          guests: [...realGuests, ...remainingAutoGenerated],
          couples: newCouples,
          exclusions: newExclusions,
          planNeedsRegeneration: state.result !== null,
        }));
      },

      // Generation Actions
      generate: () => {
        set({ isGenerating: true });
        
        const { guests, couples, exclusions, configuration, result: previousResult } = get();
        
        // Sauvegarder les noms personnalisés des tables avant régénération
        const customTableNames = new Map<number, string>();
        if (previousResult) {
          for (const table of previousResult.tables) {
            // Vérifier si le nom a été personnalisé (différent du nom par défaut)
            const defaultName = table.number === 1 
              ? "Table d'honneur" 
              : `Table ${table.number}`;
            if (table.name !== defaultName) {
              customTableNames.set(table.number, table.name);
            }
          }
        }
        
        const result = generateSeatingPlan({
          guests,
          couples,
          exclusions,
          configuration,
        });
        
        // Restaurer les noms personnalisés
        for (const table of result.tables) {
          const customName = customTableNames.get(table.number);
          if (customName) {
            table.name = customName;
          }
        }
        
        // Initialiser les positions des tables pour la vue visuelle
        // Table d'honneur centrée en haut, autres tables en grille en dessous
        const tablePositions: TablePosition[] = result.tables.map((table, index) => {
          if (index === 0) {
            // Table d'honneur centrée en haut
            return {
              tableId: table.id,
              x: 400, // Centrée horizontalement
              y: 50,  // En haut
            };
          }
          // Autres tables en grille (3 colonnes)
          const gridIndex = index - 1;
          return {
            tableId: table.id,
            x: 100 + (gridIndex % 3) * 280,
            y: 280 + Math.floor(gridIndex / 3) * 220,
          };
        });
        
        set({
          result,
          isGenerating: false,
          tablePositions,
          planNeedsRegeneration: false,
        });
      },

      // UI Actions
      setViewMode: (mode) => {
        set({ viewMode: mode });
      },

      updateTablePosition: (tableId, x, y) => {
        set((state) => ({
          tablePositions: state.tablePositions.map((tp) =>
            tp.tableId === tableId ? { ...tp, x, y } : tp
          ),
        }));
      },

      // Drag & Drop Actions
      moveGuestToTable: (guestId, targetTableId) => {
        set((state) => {
          if (!state.result) return state;
          
          const guest = state.guests.find((g) => g.id === guestId);
          if (!guest) return state;
          
          // Vérifier si l'invité est déjà dans la table cible
          const targetTable = state.result.tables.find((t) => t.id === targetTableId);
          if (targetTable?.guests.some((g) => g.id === guestId)) {
            return state;
          }
          
          const newTables = state.result.tables.map((table) => {
            // Retirer l'invité de sa table actuelle
            const filteredGuests = table.guests.filter((g) => g.id !== guestId);
            
            // Ajouter l'invité à la table cible
            if (table.id === targetTableId) {
              return {
                ...table,
                guests: [...filteredGuests, guest],
              };
            }
            
            return {
              ...table,
              guests: filteredGuests,
            };
          });
          
          return {
            result: {
              ...state.result,
              tables: newTables,
            },
          };
        });
      },

      // Table Actions
      renameTable: (tableId, newName) => {
        set((state) => {
          if (!state.result) return state;
          
          const newTables = state.result.tables.map((table) =>
            table.id === tableId ? { ...table, name: newName } : table
          );
          
          return {
            result: {
              ...state.result,
              tables: newTables,
            },
          };
        });
      },

      // Reset
      reset: () => {
        set(initialState);
      },
    }),
    {
      name: 'plantable-storage',
      partialize: (state) => ({
        guests: state.guests,
        couples: state.couples,
        exclusions: state.exclusions,
        configuration: state.configuration,
        result: state.result,
        tablePositions: state.tablePositions,
      }),
    }
  )
);
